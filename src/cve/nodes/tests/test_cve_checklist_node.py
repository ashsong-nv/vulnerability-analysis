# SPDX-FileCopyrightText: Copyright (c) 2024-2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pytest
import asyncio
from ..cve_checklist_node import _parse_list



EXPECTED_OUTPUT_FOR_INPUT_WITHOUT_SQUARE_BRACKETS = [[
                            'Verify Decompression Function Usage: Review the code within the container image to check if the decompression function of registry-support is being used. This function is the specific target of the vulnerability. Does the codebase contain calls to this function, especially when handling .tar archives?',
                            'Assess Archive Handling Practices: Evaluate how the application handles .tar archives, particularly those that could be specially modified to exploit this vulnerability. Check if there are any input validation or sanitization mechanisms in place to prevent an attacker from tricking a user into opening a malicious archive.',
                            'Inspect Devfile Parsing Logic: Does the codebase parse devfiles that use the `parent` or `plugin` keywords? If so, assess how these devfiles are handled, especially in relation to downloading archives and the potential for an attacker to cause the cleanup process to overwrite or delete files outside of the archive.',
                            'Review Cleanup Process Implementation: Investigate the implementation of the cleanup process following decompression. Check if the process is designed to prevent overwriting or deleting files outside the intended scope, and if there are any safeguards in place to mitigate this vulnerability.']]

EXPECTED_OUTPUT_FOR_INPUT_WITH_SQUARE_BRACKETS = [[
                            'Verify Kube-proxy Usage on Windows: Is the kube-proxy component running on a Windows environment within the container? This vulnerability specifically affects kube-proxy on Windows.',
                            "Inspect LoadBalancer Service Configuration: Review the configuration of LoadBalancer Services within the cluster. Are there any LoadBalancer Services where the LoadBalancer controller does not set the 'status.loadBalancer.ingress[].ip' field? This is a critical condition for the vulnerability to be exploitable.",
                            "Assess Traffic Forwarding Behavior: Evaluate how kube-proxy handles traffic forwarding in the absence of the 'status.loadBalancer.ingress[].ip' field. Is there a possibility that traffic could be unintentionally forwarded to local processes listening on the same port as the LoadBalancer Service?",
                            'Check for HNS Policy Creation: Verify if a Host Network Service (HNS) policy is created for LoadBalancer Services with empty or invalid external load balancer IPs. The absence of such a policy could lead to a Man-in-the-Middle (MITM) vulnerability.']]


@pytest.mark.asyncio
async def test_cve_checklist_parse_list():
    input_without_square_brackets = '[\n\t"Verify Decompression Function Usage: Review the code within the container image to check if the decompression function of registry-support is being used. This function is the specific target of the vulnerability. Does the codebase contain calls to this function, especially when handling .tar archives?",\n\t"Assess Archive Handling Practices: Evaluate how the application handles .tar archives, particularly those that could be specially modified to exploit this vulnerability. Check if there are any input validation or sanitization mechanisms in place to prevent an attacker from tricking a user into opening a malicious archive.",\n\t"Inspect Devfile Parsing Logic: Does the codebase parse devfiles that use the `parent` or `plugin` keywords? If so, assess how these devfiles are handled, especially in relation to downloading archives and the potential for an attacker to cause the cleanup process to overwrite or delete files outside of the archive.",\n\t"Review Cleanup Process Implementation: Investigate the implementation of the cleanup process following decompression. Check if the process is designed to prevent overwriting or deleting files outside the intended scope, and if there are any safeguards in place to mitigate this vulnerability."\n]'
    # Test input of list containing square brackets as content
    input_with_square_brackets_list = ['[\n\t"Verify Kube-proxy Usage on Windows: Is the kube-proxy component running on a Windows environment within the container? This vulnerability specifically affects kube-proxy on Windows.",\n\t"Inspect LoadBalancer Service Configuration: Review the configuration of LoadBalancer Services within the cluster. Are there any LoadBalancer Services where the LoadBalancer controller does not set the \'status.loadBalancer.ingress[].ip\' field? This is a critical condition for the vulnerability to be exploitable.",\n\t"Assess Traffic Forwarding Behavior: Evaluate how kube-proxy handles traffic forwarding in the absence of the \'status.loadBalancer.ingress[].ip\' field. Is there a possibility that traffic could be unintentionally forwarded to local processes listening on the same port as the LoadBalancer Service?",\n\t"Check for HNS Policy Creation: Verify if a Host Network Service (HNS) policy is created for LoadBalancer Services with empty or invalid external load balancer IPs. The absence of such a policy could lead to a Man-in-the-Middle (MITM) vulnerability."\n]']
    result = await _parse_list(input_with_square_brackets_list)
    assert result == EXPECTED_OUTPUT_FOR_INPUT_WITH_SQUARE_BRACKETS
    input_without_square_brackets_list = [input_without_square_brackets]
    result = await _parse_list(input_without_square_brackets_list)
    assert result == EXPECTED_OUTPUT_FOR_INPUT_WITHOUT_SQUARE_BRACKETS
    result = await _parse_list([f"some-prefix{input_without_square_brackets}some-suffix"])
    assert result == EXPECTED_OUTPUT_FOR_INPUT_WITHOUT_SQUARE_BRACKETS